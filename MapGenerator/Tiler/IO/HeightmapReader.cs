using System;
using System.IO;
using Tiler.Model;

namespace Tiler.IO
{
    /// <summary>
    /// Strict binary reader for .heightmap files generated by the Heightmap Engine.
    ///
    /// Format (binary, little-endian):
    ///
    ///   Offset  Size   Type   Meaning
    ///   0       4      u32    map_width_in_cells
    ///   4       4      u32    map_height_in_cells
    ///   8       8      u64    deterministic_seed
    ///   16      N      u8[]   height values (row-major), N = width * height
    ///   16+N    N      u8[]   terrain layers (row-major), N = width * height
    ///
    /// This reader is intentionally defensive:
    /// - Validates dimensions
    /// - Validates exact file length
    /// - Validates terrain layer byte range
    ///
    /// The reader performs NO interpretation of heights or terrain.
    /// It only loads truth into memory.
    /// </summary>
    public static class HeightmapReader
    {
        /// <summary>
        /// Reads and validates a .heightmap file, returning an immutable HeightmapData structure.
        ///
        /// Determinism:
        /// - This function is deterministic for the same file content.
        /// - It does not use system time, random numbers, or platform-specific behaviors.
        ///
        /// Coordinate convention for returned arrays:
        /// - (0,0) is top-left
        /// - x increases right
        /// - y increases down
        /// - Heights[x,y] and TerrainLayers[x,y] are the cell values at those coordinates
        /// </summary>
        /// <param name="path">Path to a .heightmap file on disk.</param>
        /// <returns>Fully validated HeightmapData.</returns>
        /// <exception cref="FileNotFoundException">Thrown if path does not exist.</exception>
        /// <exception cref="InvalidDataException">
        /// Thrown when the file violates the binary format contract.
        /// </exception>
        public static HeightmapData Read(string path)
        {
            // ---- Basic existence check ----
            // We fail fast rather than producing confusing downstream exceptions.
            if (!File.Exists(path))
            {
                throw new FileNotFoundException("Heightmap file not found.", path);
            }

            // ---- Open the file as a read-only stream ----
            // Using 'using' ensures file handles are released deterministically.
            using FileStream stream = File.OpenRead(path);

            // BinaryReader reads little-endian primitives by default on .NET.
            // This matches the contract: "binary, little-endian".
            using BinaryReader reader = new BinaryReader(stream);

            // ---- Read header ----
            // These must be read in order and in the exact sizes defined by the contract.

            uint widthInCells = reader.ReadUInt32();
            uint heightInCells = reader.ReadUInt32();
            ulong deterministicSeed = reader.ReadUInt64();

            // ---- Validate dimensions ----
            // Width/height of 0 indicates file corruption or invalid generation.
            if (widthInCells == 0 || heightInCells == 0)
            {
                throw new InvalidDataException(
                    "Invalid .heightmap header: width and height must both be > 0.");
            }

            // ---- Compute cell count safely ----
            // Use ulong to avoid overflow in multiplication for large values.
            ulong cellCount = (ulong)widthInCells * (ulong)heightInCells;

            // We will allocate 2D arrays and loop using indices,
            // so we need to ensure we can represent the total size in memory.
            if (cellCount > int.MaxValue)
            {
                throw new InvalidDataException(
                    "Heightmap is too large to load into memory safely (cellCount > int.MaxValue).");
            }

            // ---- Validate file length exactly ----
            // Contract says:
            //   header = 16 bytes
            //   heights = N bytes
            //   terrain = N bytes
            // total = 16 + 2N
            long expectedSize = 16 + (long)cellCount * 2;

            if (stream.Length != expectedSize)
            {
                throw new InvalidDataException(
                    $"Invalid .heightmap file size. Expected {expectedSize} bytes, got {stream.Length} bytes.");
            }

            // ---- Allocate output arrays ----
            // We expose arrays as [x,y] for clarity.
            byte[,] heights = new byte[widthInCells, heightInCells];
            TerrainLayer[,] terrainLayers = new TerrainLayer[widthInCells, heightInCells];

            // ---- Read height bytes (row-major) ----
            // Row-major means:
            //   for y in 0..H-1:
            //     for x in 0..W-1:
            //       read next byte
            //
            // We then store it in [x,y] so that all processing code naturally uses (x,y).
            for (uint y = 0; y < heightInCells; y++)
            {
                for (uint x = 0; x < widthInCells; x++)
                {
                    heights[x, y] = reader.ReadByte();
                }
            }

            // ---- Read terrain bytes (row-major) ----
            // Terrain bytes must be in the range [0..3].
            // Any value outside this range is a contract violation / corruption.
            for (uint y = 0; y < heightInCells; y++)
            {
                for (uint x = 0; x < widthInCells; x++)
                {
                    byte rawLayer = reader.ReadByte();

                    if (rawLayer > 3)
                    {
                        throw new InvalidDataException(
                            $"Invalid terrain layer value {rawLayer} at cell ({x},{y}). " +
                            "Valid range is 0..3.");
                    }

                    terrainLayers[x, y] = (TerrainLayer)rawLayer;
                }
            }

            // ---- Final sanity check ----
            // We should always have consumed the entire file if lengths matched.
            if (reader.BaseStream.Position != stream.Length)
            {
                throw new InvalidDataException(
                    "Reader did not consume entire .heightmap file. This indicates a parsing bug.");
            }

            // ---- Return immutable container ----
            return new HeightmapData(
                widthInCells,
                heightInCells,
                deterministicSeed,
                heights,
                terrainLayers);
        }
    }
}
